import paho.mqtt.client as mqtt
import json
import base64
import time
import sys, getopt
import Queue
import random
import struct

#============================ defines =========================================
BROKER_ADDRESS        = "argus.paris.inria.fr"

BSP_RADIO_TX_IHEX     = '01bsp_radio_tx_prog-subghz.ihex'
BSP_RADIO_RX_IHEX     = '01bsp_radio_rx_prog-subghz.ihex'

# BSP_RADIO_TX_IHEX     = '01bsp_radio_tx_prog-24ghz.ihex'
# BSP_RADIO_RX_IHEX     = '01bsp_radio_rx_prog-24ghz.ihex'


#============================ class ===========================================
class mqtt_client(object):

    cmd_list    = {'status', 'program'}
    resp_list   = {'status', 'program'}
    notif_list  = {'frommoteserialbytes'}
        
    def __init__(self, clientId, deviceType='box', deviceId='all', cmd=None, resp=None, notif=None, ot_resp_timeout=10, image_path=None, motelist=None):
        
        self.clientId           = clientId
        self.deviceType         = deviceType
        self.deviceId           = deviceId
        self.cmd                = cmd
        self.resp               = resp
        self.notif              = notif
        
        self.ot_resp_timeout    = ot_resp_timeout
        
        self.image_path = image_path
        self.image      = None
        self.image_name = ''
        
        if not self.image_path is None:
            with open(self.image_path,'rb') as f:
                self.image = base64.b64encode(f.read())
            self.image_name = image_path.split('/')[-1]
        
        if motelist is None:
            self.motelist   = set()
        else:
            self.motelist   = motelist
            self.motes_pdr  = {}
            for mote in motelist:
                self.motes_pdr[mote] = {}
                self.motes_pdr[mote]['previousFrame']         =   0
                self.motes_pdr[mote]['frameCounter']          =   0
                self.motes_pdr[mote]['pdr']                   =   0
                self.motes_pdr[mote]['rxpk_num_overflow'] =   False
                
            # print self.motes_pdr
        
        self.mqtt_topic_cmd     = 'opentestbed/deviceType/{0}/deviceId/{1}/cmd/{2}'.format(self.deviceType, self.deviceId , self.cmd)
        if self.deviceId == 'all':
            self.mqtt_topic_resp    = 'opentestbed/deviceType/{0}/deviceId/+/resp/{1}'.format(self.deviceType, self.resp)
        else:
            self.mqtt_topic_resp    = 'opentestbed/deviceType/{0}/deviceId/{1}/resp/{2}'.format(self.deviceType, self.deviceId , self.resp)
        self.mqtt_topic_notif   = 'opentestbed/deviceType/{0}/deviceId/{1}/notif/{2}'.format(self.deviceType, self.deviceId , self.notif)
        
        self.mqttclient = None
        
        
    #==== mqtt admin

    def connect_to_mqtt(self):
    
        self.mqttclient                = mqtt.Client(self.clientId)
        self.mqttclient.on_connect     = self._on_mqtt_connect
        self.mqttclient.on_message     = self._on_mqtt_message
        self.mqttclient.connect(BROKER_ADDRESS)
        self.mqttclient.loop_start()
        
        # wait for a while to gather the response from otboxes
        time.sleep(self.ot_resp_timeout)
        
        # close the client and return the motes list
        self.mqttclient.loop_stop()
        
        # print "{0} motes are found".format(len(self.motelist))
    
    def _on_mqtt_connect(self, client, userdata, flags, rc):
        
        if not self.resp is None:
            # print "subscribe to ", self.mqtt_topic_resp
            client.subscribe(self.mqtt_topic_resp)
            
        if not self.notif is None:
            # print "subscribe to ", self.mqtt_topic_notif
            client.subscribe(self.mqtt_topic_notif)
            
        if not self.cmd is None:
                
            payload={
                'token':       123,
            }
            
            if self.cmd == 'program':
                payload['description'] = self.image_name
                payload['hex']         = self.image
            
            # print "publish ", self.mqtt_topic_cmd
            client.publish(
                topic   = self.mqtt_topic_cmd,
                payload = json.dumps(payload),
            )
            
            
    def _on_mqtt_message(self, client, userdata, message):
        
        if self.resp == 'status':
            self.handle_resp_for_status_cmd(message)
        elif self.resp == 'program':
            self.handle_resp_for_program_cmd(message)
        elif self.notif == 'frommoteserialbytes':
            self.handle_notif_frommoteserialbytes(message)
            
    #==== mqtt message publisher
        
    #==== mqtt response message handlers
    
    def handle_resp_for_status_cmd(self, message):
        
        # get the eui64 from message payload
        payload_status = json.loads(message.payload)
        
        for mote in payload_status['returnVal']['motes']:
            if 'EUI64' in mote:
                self.motelist.add(mote['EUI64'])
        
        
    def handle_resp_for_program_cmd(self, message):
        
        # get the eui64 from message topic
        self.motelist.add(message.topic.split('/')[4])
        
    #==== mqtt notify message handlers
    
    def handle_notif_frommoteserialbytes(self, message):
        
        try:
            serialbytes = json.loads(message.payload)['serialbytes']
        except:
            print "Error: failed to parse message payload {0}".format(message.payload)
        else:
            mote_eui64 = message.topic.split('/')[4]
            
            # splite frames
            rawFrames = []
            frameStart = 0
            for i in range(len(serialbytes)-1):
                if serialbytes[i]!=255 and serialbytes[i+1]==255:
                    rawFrames.append(serialbytes[frameStart:i+1])
                if serialbytes[i]==255 and serialbytes[i+1]!=255:
                    frameStart = i+1
            
            # parsing the serial bytes
            try:
                for rawFrame in rawFrames:
                    if len(rawFrame)==5:
                        self.motes_pdr[mote_eui64]['frameCounter'] += 1
                        (rxpk_len,rxpk_num,rxpk_rssi,rxpk_lqi,rxpk_crc) = \
                            struct.unpack('>BBbBB', ''.join([chr(b) for b in rawFrame]))
                        # print 'len={0:<3} num={1:<3} rssi={2:<4} lqi={3:<3} crc={4}'.format(
                            # rxpk_len,
                            # rxpk_num,
                            # rxpk_rssi,
                            # rxpk_lqi,
                            # rxpk_crc
                        # )
                        if self.motes_pdr[mote_eui64]['previousFrame']>rxpk_num:
                            # the rxpk_num maybe not start with 1 when the script runs, 
                            # record the pdr when rxpk_num overflow
                            if self.motes_pdr[mote_eui64]['rxpk_num_overflow']:
                                self.motes_pdr[mote_eui64]['pdr'] = self.motes_pdr[mote_eui64]['frameCounter']
                            self.motes_pdr[mote_eui64]['previousFrame'] = 0
                            self.motes_pdr[mote_eui64]['frameCounter']  = 0
                            self.motes_pdr[mote_eui64]['rxpk_num_overflow'] = True
                        else:
                            self.motes_pdr[mote_eui64]['previousFrame'] = rxpk_num
            except ValueError as err:
                print err
            except:
                print "Unexpected error:", sys.exc_info()[0]
                print "signle frame {0} at mote {1}".format(rawFrame, mote_eui64)
                raise
        
            # print "receive serial bytes {0} frome mote {1}".format(message.topic.split('/')[4],serialbytes)
            
            
    def get_motelist(self):
        return self.motelist
        
    def get_motes_pdr(self):
        return self.motes_pdr
        
#============================ main function ===================================
        
#==== get motes list

# send status cmd and get eui64 of each motes

getmotelist_client = mqtt_client(clientId = 'getmotelist', deviceType='box',deviceId='all',cmd='status',resp='status')
getmotelist_client.connect_to_mqtt()
motelist = getmotelist_client.get_motelist()
print motelist
print '============================================================'

#==== get connectivity of motes on testbed

progress = 0

for mote in motelist:
    # calculate pdr from mote eui64_Tx_mote_xxxxxxxx to other motes 
    
    #==== program motes
    
    # program all most motes with BSP_RADIO_RX ihex
    program_all_client = mqtt_client(clientId = 'program_all_motes', deviceType='mote',deviceId='all',cmd='program',resp='program', image_path=BSP_RADIO_RX_IHEX, ot_resp_timeout=20)
    program_all_client.connect_to_mqtt()
    resultlist = program_all_client.get_motelist()
    # print resultlist
    
    # program one mote with BSP_RADIO_TX ihex
    program_one_client = mqtt_client(clientId = 'program_one_mote', deviceType='mote',deviceId=mote,cmd='program',resp='program', image_path=BSP_RADIO_TX_IHEX, ot_resp_timeout=20)
    program_one_client.connect_to_mqtt()
    resultlist = program_one_client.get_motelist()
    # print resultlist
    
    #==== get serial data

    # subscribe fromserialbytes cmd
    get_serialbytes_client = mqtt_client(clientId = 'get_all_serialbytes_client', deviceType='mote',deviceId='+',notif='frommoteserialbytes', ot_resp_timeout=20, motelist=motelist)
    get_serialbytes_client.connect_to_mqtt()
    resultpdr = get_serialbytes_client.get_motes_pdr()
    with open('result.txt','a') as f:
        f.write("Tx mote: {0}\n".format(mote))
        f.write("-----------------------------------\n")
        for item in resultpdr:
            f.write("Rx mote: {0} pdr: {1}\n".format(item, resultpdr[item]['pdr']))
        f.write("===================================\n")
        
    progress += 1
    print "Got connectivity (pdr) with TX mote {0} .... progress: {1}/{2}\n".format(mote,progress,len(motelist))
    
